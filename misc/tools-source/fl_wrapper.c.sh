#!/bin/bash
#
# This shell-script generates the fl_wrapper.c source file.

cat << EOT
/* ROCK Linux Wrapper for getting a list of created files
 *
 * --- ROCK-COPYRIGHT-NOTE-BEGIN ---
 * 
 * This copyright note is auto-generated by ./scripts/Create-CopyPatch.
 * Please add additional copyright information _after_ the line containing
 * the ROCK-COPYRIGHT-NOTE-END tag. Otherwise it might get removed by
 * the ./scripts/Create-CopyPatch script. Do not edit this copyright text!
 * 
 * ROCK Linux: rock-src/misc/tools-source/fl_wrapper.c.sh
 * ROCK Linux is Copyright (C) 1998 - 2006 Clifford Wolf
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version. A copy of the GNU General Public
 * License can be found at Documentation/COPYING.
 * 
 * Many people helped and are helping developing ROCK Linux. Please
 * have a look at http://www.rocklinux.org/ and the Documentation/TEAM
 * file for details.
 * 
 * --- ROCK-COPYRIGHT-NOTE-END ---
 *
 * Copyright (C) 2004-2005 The T2 SDE Project
 *
 * gcc -Wall -O2 -ldl -shared -o fl_wrapper.so fl_wrapper.c
 *
 * !!! THIS FILE IS AUTO-GENERATED BY $0 !!!
 *
 * ELF Dynamic Loading Documentation:
 *  - http://www.linuxdoc.org/HOWTO/GCC-HOWTO-7.html
 *  - http://www.educ.umu.se/~bjorn/mhonarc-files/linux-gcc/msg00576.html
 *  - /usr/include/dlfcn.h
 */


/* Headers and prototypes */

#define DEBUG 1
#define DLOPEN_LIBC 1
#define FD_TRACKER 1

#define _GNU_SOURCE
#define _REENTRANT

#define open   xxx_open
#define open64 xxx_open64
#define mknod  xxx_mknod

#define _LARGEFILE_SOURCE
#define _LARGEFILE64_SOURCE

#  include <dlfcn.h>
#  include <errno.h>
#  include <fcntl.h>
#  include <stdio.h>
#  include <stdlib.h>
#  include <string.h>
#  include <sys/stat.h>
#  include <sys/types.h>
#  include <unistd.h>
#  include <utime.h>
#  include <stdarg.h>
#  include <sched.h>

#undef _LARGEFILE64_SOURCE
#undef _LARGEFILE_SOURCE

#undef mknod
#undef open
#undef open64

static void * get_dl_symbol(char *);

struct status_t {
	ino_t   inode;
	off_t   size;
	time_t  mtime;
	time_t  ctime;
};

static void handle_file_access_before(const char *, const char *, struct status_t *);
static void handle_file_access_after(const char *, const char *, struct status_t *);

char *wlog = 0, *rlog = 0, *cmdname = "unkown";

#  if DEBUG == 1
int debug = 0;
#  endif

/* Wrapper Functions */
EOT

# This has been made with cpp-macros before until they turned to be absolutely
# unreadable ...
#
add_wrapper()
{
	line="$( echo "$*" | sed 's/ *, */,/g' )"
	old_ifs="$IFS" ; IFS="," ; set $line ; IFS="$old_ifs"

	ret_type=$1 ; shift ; function=$1 ; shift
	p1="" ; p2="" ; for x ; do p1="$p1$x, " ; done
	for x ; do x="${x%%'[]'}" ; p2="$p2${x##* }, " ; done
	p1="${p1%, }" ; p2="${p2%, }"

	if [ "${function#exec}" = "${function}" ]
	then
		echo ; cat << EOT
extern $ret_type $function($p1);
$ret_type (*orig_$function)($p1) = 0;

$ret_type $function($p1)
{
	struct status_t status;
	int old_errno=errno;
	$ret_type rc;

	handle_file_access_before("$function", f, &status);
	if (!orig_$function) orig_$function = get_dl_symbol("$function");

#  if DEBUG == 1
	if (debug) fprintf(stderr, "fl_wrapper.so debug [%d]: going to run original $function() at %p (wrapper is at %p).\n",
		getpid(), orig_$function, $function);
#  endif

	errno=old_errno;
	rc = orig_$function($p2);
	old_errno=errno;

	handle_file_access_after("$function", f, &status);

	errno=old_errno;
	return rc;
}
EOT
	else
		echo ; cat << EOT
extern int fcntl(int fd, int cmd, ...);

extern $ret_type $function($p1);
$ret_type (*orig_$function)($p1) = 0;

$ret_type $function($p1)
{
	int old_errno=errno;
	int rc;

	handle_file_access_after("$function", f, 0);
	if (!orig_$function) orig_$function = get_dl_symbol("$function");
	if (!orig_fcntl) orig_fcntl = get_dl_symbol("fcntl");

#  if FD_TRACKER == 1
	struct pid_reg *pid = *find_pid(getpid());
	struct fd_reg ** fd_iter;
	if (pid)
	{
		fd_iter = &pid->fd_head;
		while (*fd_iter != 0)
		{
			(*fd_iter)->closed = orig_fcntl((*fd_iter)->fd, F_GETFD) & FD_CLOEXEC;
			fd_iter = &(*fd_iter)->next;
		}
		pid->executed = 1;
	}
#  endif

#  if DEBUG == 1
	if (debug) fprintf(stderr, "fl_wrapper.so debug [%d]: going to run original $function() at %p (wrapper is at %p).\n",
		getpid(), orig_$function, $function);
#  endif

	errno=old_errno;
	rc = orig_$function($p2);
	old_errno=errno;

# if FD_TRACKER == 1
	if (pid)
	{
		fd_iter = &pid->fd_head;
		while (*fd_iter != 0)
		{
			(*fd_iter)->closed = 0;
			fd_iter = &(*fd_iter)->next;
		}
		pid->executed = 0;
	}
# endif

	errno=old_errno;
	return rc;
}
EOT
	fi
}

echo
cat fd_tracker.c
cat fl_wrapper_execl.c
cat fl_wrapper_open.c
cat fl_wrapper_close.c


# add_wrapper 'FILE*, fopen,   const char* f, const char* g'
# add_wrapper 'FILE*, fopen64, const char* f, const char* g'

add_wrapper 'int,   mkdir,   const char* f, mode_t m'
add_wrapper 'int,   mknod,   const char* f, mode_t m, dev_t d'

add_wrapper 'int,   link,    const char* s, const char* f'
add_wrapper 'int,   symlink, const char* s, const char* f'
add_wrapper 'int,   rename,  const char* s, const char* f'

add_wrapper 'int,   utime,   const char* f, const struct utimbuf* t'
add_wrapper 'int,   utimes,  const char* f, struct timeval* t'

add_wrapper 'int,   execv,   const char* f, char* const a[]'
add_wrapper 'int,   execve,  const char* f, char* const a[], char* const e[]'

echo
cat fl_wrapper_internal.c
