# --- ROCK-COPYRIGHT-NOTE-BEGIN ---
# 
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# Please add additional copyright information _after_ the line containing
# the ROCK-COPYRIGHT-NOTE-END tag. Otherwise it might get removed by
# the ./scripts/Create-CopyPatch script. Do not edit this copyright text!
# 
# ROCK Linux: rock-src/package/avm/lyx/hotfix-binutils-gcc.patch
# ROCK Linux is Copyright (C) 1998 - 2006 Clifford Wolf
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# 
# --- ROCK-COPYRIGHT-NOTE-END ---

Hotfix needed for new binutils (bug is in gcc)
(see http://gcc.gnu.org/bugzilla/show_bug.cgi?id=16625)

--- ./boost/boost/regex/detail/regex_match.hpp.orig	2003-02-20 17:02:07.000000000 +0100
+++ ./boost/boost/regex/detail/regex_match.hpp	2005-06-14 12:11:03.000000000 +0200
@@ -458,6 +458,10 @@
          ptr = ptr->next.p;
          break;
       }
+
+/* HACK! HACK! HACK! */
+default: switch(ptr->type) {
+
       case syntax_element_start_line:
          outer_line_check:
          if(first == temp_match[0].first)
@@ -553,6 +557,10 @@
          }
          goto failure;
       }
+
+/* HACK! HACK! HACK! */
+default: switch(ptr->type) {
+
       case syntax_element_within_word:
          // both prev and this character must be traits::char_class_word:
          if(traits_inst.is_class(*first, traits::char_class_word))
@@ -620,6 +628,10 @@
          // OK match:
          ptr = ptr->next.p;
          break;
+
+/* HACK! HACK! HACK! */
+default: switch(ptr->type) {
+
       case syntax_element_buffer_end:
          if((first != last) || (flags & match_not_eob))
             goto failure;
@@ -662,6 +674,10 @@
             continue;
          }
          goto failure;
+
+/* HACK! HACK! HACK! */
+default: switch(ptr->type) {
+
       case syntax_element_jump:
          ptr = static_cast<const re_jump*>(ptr)->alt.p;
          continue;
@@ -819,6 +835,10 @@
          while((first != last) && traits_inst.is_combining(traits_inst.translate(*first, icase)))++first;
          ptr = ptr->next.p;
          continue;
+
+/* HACK! HACK! HACK! */
+default: switch(ptr->type) {
+
       case syntax_element_soft_buffer_end:
          {
             if(flags & match_not_eob)
@@ -838,6 +858,10 @@
       default:
          jm_assert(0); // should never get to here!!
          return false;
+
+/* HACK! HACK! HACK! */
+} } } } }
+
       }
    }
 
@@ -860,6 +884,10 @@
          goto end_mark_jump;
       case syntax_element_start_line:
          goto outer_line_check;
+
+/* HACK! HACK! HACK! */
+default: switch(ptr->type) {
+
       case syntax_element_end_line:
          // we're at the end so *first is never valid:
          if((flags & match_not_eol) == 0)
@@ -881,6 +909,10 @@
             }
          }
          goto failure;
+
+/* HACK! HACK! HACK! */
+default: switch(ptr->type) {
+
       case syntax_element_buffer_end:
       case syntax_element_soft_buffer_end:
          if(flags & match_not_eob)
@@ -917,6 +949,10 @@
             continue;
          }
          goto failure;  // neither option is possible
+
+/* HACK! HACK! HACK! */
+default: switch(ptr->type) {
+
       case syntax_element_rep:
          // if we're moving to a higher id (nested repeats etc)
          // zero out our accumualtors:
@@ -959,6 +995,10 @@
       default:
          goto failure;
       }
+
+/* HACK! HACK! HACK! */
+} } }
+
    }
 
    failure:
