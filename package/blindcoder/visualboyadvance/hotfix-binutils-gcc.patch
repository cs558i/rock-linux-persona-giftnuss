# --- ROCK-COPYRIGHT-NOTE-BEGIN ---
# 
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# Please add additional copyright information _after_ the line containing
# the ROCK-COPYRIGHT-NOTE-END tag. Otherwise it might get removed by
# the ./scripts/Create-CopyPatch script. Do not edit this copyright text!
# 
# ROCK Linux: rock-src/package/blindcoder/visualboyadvance/hotfix-binutils-gcc.patch
# ROCK Linux is Copyright (C) 1998 - 2006 Clifford Wolf
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# 
# --- ROCK-COPYRIGHT-NOTE-END ---

Hotfix needed for new binutils (bug is in gcc)
(see http://gcc.gnu.org/bugzilla/show_bug.cgi?id=16625)

--- ./src/Gfx.h.orig	2004-10-10 10:50:57.000000000 +0200
+++ ./src/Gfx.h	2004-10-10 11:04:57.000000000 +0200
@@ -763,6 +763,8 @@
       case 3:
         sizeX = sizeY = 64;
         break;
+      default:
+      switch(((a0 >>12) & 0x0c)|(a1>>14)) {
       case 4:
         sizeX = 16;
         break;
@@ -777,6 +779,8 @@
         sizeX = 64;
         sizeY = 32;
         break;
+      default:
+      switch(((a0 >>12) & 0x0c)|(a1>>14)) {
       case 8:
         sizeY = 16;
         break;
@@ -793,6 +797,7 @@
         break;
       default:
         continue;
+      }}
       }
 
 #ifdef SPRITE_DEBUG
@@ -1167,6 +1172,8 @@
       case 3:
         sizeX = sizeY = 64;
         break;
+      default:
+      switch(((a0 >>12) & 0x0c)|(a1>>14)) {
       case 4:
         sizeX = 16;
         break;
@@ -1181,6 +1188,8 @@
         sizeX = 64;
         sizeY = 32;
         break;
+      default:
+      switch(((a0 >>12) & 0x0c)|(a1>>14)) {
       case 8:
         sizeY = 16;
         break;
@@ -1197,6 +1206,7 @@
         break;
       default:
         continue;
+      }}
       }
 
       int sy = (a0 & 255);
--- ./src/GBAinline.h.orig	2004-10-10 10:50:08.000000000 +0200
+++ ./src/GBAinline.h	2004-10-10 11:13:05.000000000 +0200
@@ -74,6 +74,8 @@
   case 3:
     value = READ32LE(((u32 *)&internalRAM[address & 0x7ffC]));
     break;
+  default:
+  switch(address >> 24) {
   case 4:
     if((address < 0x4000400) && ioReadable[address & 0x3fc]) {
       if(ioReadable[(address & 0x3fc) + 2])
@@ -91,10 +93,14 @@
   case 7:
     value = READ32LE(((u32 *)&oam[address & 0x3FC]));
     break;
+  default:
+  switch(address >> 24) {
   case 8:
   case 9:
   case 10:
   case 11:
+  default:
+  switch(address >> 24) {
   case 12:
     value = READ32LE(((u32 *)&rom[address&0x1FFFFFC]));
     break;    
@@ -128,6 +134,7 @@
       //      value = *((u32 *)&bios[address & 0x3ffc]);
       //    }
       //        return 0xFFFFFFFF;
+  }}}
   }
 
   if(address & 3) {
@@ -190,6 +197,8 @@
   case 3:
     value = READ16LE(((u16 *)&internalRAM[address & 0x7ffe]));
     break;
+  default:
+  switch(address >> 24) {
   case 4:
     if((address < 0x4000400) && ioReadable[address & 0x3fe])
       value =  READ16LE(((u16 *)&ioMem[address & 0x3fe]));
@@ -204,10 +213,14 @@
   case 7:
     value = READ16LE(((u16 *)&oam[address & 0x3fe]));
     break;
+  default:
+  switch(address >> 24) {
   case 8:
   case 9:
   case 10:
   case 11:
+  default:
+  switch(address >> 24) {
   case 12:
     if(address == 0x80000c4 || address == 0x80000c6 || address == 0x80000c8)
       value = rtcRead(address);
@@ -249,6 +262,7 @@
     //      value = (value >> 8) | ((value & 0xFF) << 24);
     //    return 0xFFFF;
     break;
+  }}}
   }
 
   if(address & 1) {
