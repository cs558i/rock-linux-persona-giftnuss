# --- ROCK-COPYRIGHT-NOTE-BEGIN ---
# 
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# Please add additional copyright information _after_ the line containing
# the ROCK-COPYRIGHT-NOTE-END tag. Otherwise it might get removed by
# the ./scripts/Create-CopyPatch script. Do not edit this copyright text!
# 
# ROCK Linux: rock-src/package/kasc/xarchon/gcc34.patch
# ROCK Linux is Copyright (C) 1998 - 2006 Clifford Wolf
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# 
# --- ROCK-COPYRIGHT-NOTE-END ---

--- ./src/Problem.hpp.orig	2005-03-04 10:28:03.429496128 +0100
+++ ./src/Problem.hpp	2005-03-04 10:31:32.006787560 +0100
@@ -306,14 +306,14 @@
   virtual G Goal_Value(T *a)
   {
     if (depth==0) 
-      return tester->Goal_Value(a);
+      return this->tester->Goal_Value(a);
     
-    Goal_Test<G,T> *endtester=tester;
-    tester=new Minimax_Goal_Test(depth-1,generator,other_acc,goal_acc,tester);
+    Goal_Test<G,T> *endtester=this->tester;
+    this->tester=new Minimax_Goal_Test(depth-1,this->generator,other_acc,this->goal_acc,this->tester);
     G ret_val=Successor_Goal_Test<G,T>::Goal_Value(a);
-    delete tester;
-    tester=endtester;
-    delete next;
+    delete this->tester;
+    this->tester=endtester;
+    delete this->next;
 
     return ret_val;
   }
@@ -340,19 +340,19 @@
   
   virtual G Goal_Value(T *a)
   {
-    Goal_Accumulator <G,T> *old=goal_acc;
+    Goal_Accumulator <G,T> *old=this->goal_acc;
     Multi_Goal_Accumulator <G,T,greater<G> > *mga=new Multi_Goal_Accumulator<G,T,greater<G> >(branch);
-    goal_acc=mga;
+    this->goal_acc=mga;
     Successor_Goal_Test<G,T>::Goal_Value(a);
-    goal_acc=old;
+    this->goal_acc=old;
     for (mga->Init();!mga->IsEnd();mga->Next()) { 
       T *state=mga->Get_State();
-      Multi_Minimax_Goal_Test *next=new Multi_Minimax_Goal_Test(d-1,b,gen,other,goal_acc,tester);
+      Multi_Minimax_Goal_Test *next=new Multi_Minimax_Goal_Test(this->d-1,this->b,this->gen,other,this->goal_acc,this->tester);
       next->Goal_Value(state);
-      goal_acc->Put(accumulator->value,acc->state,acc->op);
+      this->goal_acc->Put(this->accumulator->value,this->acc->state,this->acc->op);
     }
-    goal_acc->Put(mga->Get_State(),mga->Get_Operator(),mga->Get_Result());
-    return goal_acc->Get_Value();
+    this->goal_acc->Put(mga->Get_State(),mga->Get_Operator(),mga->Get_Result());
+    return this->goal_acc->Get_Value();
   }
 };
 
--- ./src/Genetic.hpp.orig	2005-03-04 10:32:17.605855448 +0100
+++ ./src/Genetic.hpp	2005-03-04 10:40:23.161039840 +0100
@@ -216,9 +216,9 @@
   virtual Genetic_Operator<T> *Choose_Operator(void)
   {
     int max=(int)total_op_weight;
-    list<Genetic_Operator<T> *>::iterator start=operators.begin();
-    list<Genetic_Operator<T> *>::iterator end=operators.end();
-    list<Genetic_Operator<T> *>::iterator iter;
+    typename list<Genetic_Operator<T> *>::iterator start=operators.begin();
+    typename list<Genetic_Operator<T> *>::iterator end=operators.end();
+    typename list<Genetic_Operator<T> *>::iterator iter;
     int r=rand()%max;
     int count=0;
     for (iter=start;iter!=end;iter++) {
@@ -264,7 +264,7 @@
 	cur_size++;
       }
     }
-    newpop->Eval_Fitness(fit_func);
+    newpop->Eval_Fitness(this->fit_func);
     return newpop;
   }
 
