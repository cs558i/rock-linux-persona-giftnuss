#!/bin/bash
#
# --- ROCK-COPYRIGHT-NOTE-BEGIN ---
# 
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# Please add additional copyright information _after_ the line containing
# the ROCK-COPYRIGHT-NOTE-END tag. Otherwise it might get removed by
# the ./scripts/Create-CopyPatch script. Do not edit this copyright text!
# 
# ROCK Linux: rock-src/scripts/Build-Pkg
# ROCK Linux is Copyright (C) 1998 - 2006 Clifford Wolf
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version. A copy of the GNU General Public
# License can be found at Documentation/COPYING.
# 
# Many people helped and are helping developing ROCK Linux. Please
# have a look at http://www.rocklinux.org/ and the Documentation/TEAM
# file for details.
# 
# --- ROCK-COPYRIGHT-NOTE-END ---

exec 2>&1

buildstart="`date "+%m/%d/%Y from %T"`"

options=''
config=default

clear_src=1
norebuild=0
nopostinst=0
update=0

make_tar=''
prefix="usr"
prefix_auto=1
pkgdir=""
download=0
verbose=0
xtrace=0
debug=0
chroot=0
root=""
id=''
desktopfiles=''
desktopauto=1

stagelevel=9
this_is_the_2nd_run=0

#
# ----  Functions
#


help_msg() {
	spacer="                          "
	echo
	echo "Usage: ./scripts/Build-Pkg" \
	             "[ -0 | -1 | -2  ... | -8 | -9 ]            \\"
	echo "$spacer [ -v ]  [ -xtrace ]  [ -chroot ]           \\"
	echo "$spacer [ -root { <rootdir> | auto } ] [ -update ] \\"
	echo "$spacer [ -cfg <config> ]  [ -nopostinst ]         \\"
	echo "$spacer [ -prefix <prefix-dir> ]  [ -norebuild ]   \\"
	echo "$spacer [ -noclearsrc ]  [ -pkgdir <pkgdir> ]      \\"
	echo "$spacer [ -id <id> ]  [ -debug ]  pkg-name(s)"
	echo
	echo " Build a single package. Warning: Re-building a package might overwrite or"
	echo " remove configuration files; with the -update option modified files are backed"
	echo " up and restored after the package build. In most cases the other options are"
	echo " only needed by ./scripts/Build-Target when building the entire distribution."
	echo
	echo "	-0, -1, ..., -9	set build stage to 0, 1, ..., 9, respectively" 
	echo "	-v		be verbose"
	echo "	-xtrace		print additional xtrace (debug-)output to the"
	echo "			build log file"
	echo "	-chroot		create and use a chroot environment"
	echo "	-root { <rootdir> | auto }	the root build directory to use;"
	echo "					defaults to automatic setting"
	echo "	-update		backup/restore modified package files"
	echo "	-cfg <config>	the build configuration to use"
	echo "	-nopostinst	do not create postinstall files"
	echo "	-prefix <prefix-dir>		the installation prefix for packages;"
	echo "					defaults to automatic setting"
	echo "	-norebuild	don't rebuild a previously successfully built package;"
	echo "			if the \"retry broken\" Config option is set, don't"
	echo "			rebuild unsuccessfully built packages, too" 
	echo "	-noclearsrc	don't delete the package build directory (src.*)"
	echo "	-pkgdir <pkgdir>	path to package build config (package/..),"
	echo "				either absolute or relative to ROCK Linux"
	echo "				sources directory" 	
	echo "	-id <id>	use the given build id"
	echo "	-debug		enable debug mode: setup everything and exit before"
	echo "			the actual build"
	echo "	-download	download missing source files"
	echo
	echo "Type './scripts/Help Build-Pkg' for details."
	echo
}


#
# ---- Parse options + config and make Build-Pkg sub-calls
#

while [ "$1" ] ; do
	case "$1" in
		-this_is_the_2nd_run) this_is_the_2nd_run=1 ;;
		-[0-9])   options="$options $1"    ; stagelevel=${1#-} ;;
		-v)       options="$options $1"    ; verbose=1     ;;
		-xtrace)  options="$options $1"    ; xtrace=1      ;;
		-debug)   options="$options $1"    ; debug=1 ; clear_src=0 ;;
		-update)  options="$options $1"    ; update=1      ;;
		-chroot)  options="$options $1"    ; chroot=1      ;;
		-chr-sub) options="$options $1"    ; chroot=0      ;;
		-cfg)     options="$options $1 $2" ; config="$2"   ; shift ;;
		-root)    options="$options $1 $2" ; root="$2"     ; shift ;;
		-prefix)  options="$options $1 $2" ;
				prefix_auto=0      ; prefix="$2"   ; shift ;;
		-id)      options="$options $1 $2" ; id="$2"       ; shift ;;
		-pkgdir)  options="$options $1 $2" ; pkgdir="$2"   ; shift ;;
		-noclearsrc) options="$options $1" ; clear_src=0   ;;
		-norebuild)  options="$options $1" ; norebuild=1   ;;
		-nopostinst) options="$options $1" ; nopostinst=1  ;;
		-download)   options="$options $1" ; download=1    ;;
		-*) help_msg ; exit 1 ;;
		*)  break ;;
	esac
	shift
done

# check if arguments are left as package names
if [ $# = 0 ] ; then 
	help_msg ; exit 1
fi

./scripts/Check-System || exit 1
export ROCK_CHECK_SYSTEM_OK=1

. ./scripts/functions
. ./scripts/parse-config

if [ -z "$root" -a $stagelevel -le 2 ] || \
   [ -z "$root" -a $chroot -eq 1 ] || \
   [ "$root" = auto ]; then
	root="build/$ROCKCFG_ID"
fi

[ "$pkgdir" -a "${pkgdir#/}" = "$pkgdir" ] && pkgdir="$base/$pkgdir"
[ "$root" -a "${root#/}" = "$root" ] && root="$base/$root"
root=${root%/} ; xroot="$root" ; [ $stagelevel -ge 3 ] && root=""

if [ -z "$id" ] ; then
	id=`get_unique`
	options="$options -id $id"
fi

./scripts/Build-Tools -$stagelevel -cfg $config || exit 1

# more than one package are passed
if [ $# -gt 1 ] ; then 
    for x ; do
	if ! ./scripts/Build-Pkg $options $x && \
	   [ "$ROCKCFG_ABORT_ON_ERROR" = 1 ] ; then
		exit 1
	fi
    done
    exit 0
fi

# parameter 1 has $pkg=$xpkg
pkg="${1%=*}"; xpkg="${1#*=}"

builddir="$base/src.$xpkg.$id"

# get real pkg name for mapped packages
. build/$ROCKCFG_ID/ROCK/$toolsdir/lib/pkgmapper

if [ $stagelevel -le 1 ] ; then
	prefix="$tools"
fi
prefix=${prefix%/} ; prefix=${prefix#/}

# set desktop file name
desktopfiles="$( echo ${base}/package/*/${pkg} )/*.desktop"

export ROCK_PKG=$pkg
export ROCK_XPKG=$xpkg

# Set permissions and ownership of $buildir; $base/build might have different ones.
mkdir -p "$builddir"; chmod 700 "$builddir" ; chown 0:0 "$builddir"

if [ "$xroot" ] ; then
	pushd "$xroot/" >/dev/null || exit 1
	
	realconf=$(cd $base/config; pwd -P)
	realdown=$(cd $base/download; pwd -P)
	realbase=$(dirname $(cd $base/scripts; pwd -P))
	
	if [ ! -e ROCK/loop/scripts ]; then
		mkdir -p ROCK/{loop,config,download}
		mount --bind $realbase $PWD/ROCK/loop
		mount --bind $realconf $PWD/ROCK/config
		mount --bind $realdown $PWD/ROCK/download
	fi
	
	for x in Documentation architecture misc package scripts target; do
		if [ ! -e ROCK/$x ]; then ln -s "loop/$x" "ROCK/$x"; fi
	done
	
	if [ ! -e "ROCK/build/$ROCKCFG_ID" ]; then
		mkdir -p "ROCK/build"
		ln -snf ../.. "ROCK/build/$ROCKCFG_ID"
	fi
	
	# If build is a symlink to somewhere else (NFS share for clusterbuild
	# usually) we do _not_ want to extract our stuff there.
	# Network latency!
	ln -sf loop/src.$xpkg.$id ROCK/src.$xpkg.$id
	
	popd >/dev/null
fi

if [ "$chroot" = 1 ] ; then

	cd "$xroot" || exit 1

	x_mknod() {
		if [ ! -e "$1" ]; then
			mknod "$@"
		fi
	}

	mkdir -p dev/loop
	x_mknod dev/null     c 1 3
	x_mknod dev/zero     c 1 5
	x_mknod dev/random   c 1 8
	x_mknod dev/urandom  c 1 9
	x_mknod dev/loop/0   b 7 0 
	x_mknod dev/loop/1   b 7 1 
	x_mknod dev/loop/2   b 7 2 
	x_mknod dev/loop/3   b 7 3 
	x_mknod dev/tty      c 5 0
	x_mknod dev/ptmx     c 5 2

	if [ ! -L dev/fd ]; then
		ln -s /proc/self/fd dev/fd
	fi

	if [ "$ROCKCFG_PSEUDONATIVE" = 1 -a ! -f pseudonative_handler ]
	then
		echo_header "Preparing chroot dir for pseudonative build:"

		echo_status "Building pseudonative_handler."
		cc -static -o pseudonative_handler \
				$base/misc/tools-source/pseudonative_handler.c

		if [ ! -f /proc/sys/fs/binfmt_misc/register ] ; then
			echo_status "Mounting /proc/sys/fs/binfmt_misc."
			mount -t binfmt_misc binfmt_misc /proc/sys/fs/binfmt_misc
		fi

		echo_status "Registering pseudonative_handler."
		sign="$( hexdump bin/bash | head -n2 | cut -f2- -d' ' | tr -d ' \n' | \
				cut -c 1-40 | sed -e 's,\(..\)\(..\),\\x\2\\x\1,g' )"
		echo ":${arch_machine}_rock_bin:M::$sign::/pseudonative_handler:" > /proc/sys/fs/binfmt_misc/register
		sign="$( hexdump lib/libc.so.[0-9] | head -n2 | cut -f2- -d' ' | tr -d ' \n' | \
				cut -c 1-40 | sed -e 's,\(..\)\(..\),\\x\2\\x\1,g' )"
		echo ":${arch_machine}_rock_lib:M::$sign::/pseudonative_handler:" > /proc/sys/fs/binfmt_misc/register

		echo_status "Creating pseudonative bindir."
		rm -rf ROCK/tools.cross/pseudonative.bin
		mkdir -p ROCK/tools.cross/pseudonative.bin
		cd ROCK/tools.cross

		while read f
		do
			b=$(basename $f)
			a=${b#$arch_target-}
			ln -sf ../$f pseudonative.bin/$b
			if [ "$a" != "$b" ]; then
				ln -sf ../$f pseudonative.bin/$a
			fi
		done < <(
			find crosscc lib libexec $arch_target wrapper -xtype f -perm +111 | \
				xargs file -L | grep ELF.*executable | cut -f1 -d:
		)

		echo_status "Applying some bin hotfixes."
		ln -s ../bin/true pseudonative.bin/umount
		ln -s ../bin/true pseudonative.bin/mount
		rm -f bin/uname pseudonative.bin/uname

		echo_status "Creating pseudonative libdir."
		rm -rf pseudonative.lib; mkdir -p pseudonative.lib
		cp /lib/ld-linux.so.* /lib/libc.so.* pseudonative.lib/
		cp /lib/libnss_compat.so.* pseudonative.lib/
		cp /lib/libnss_files.so.* pseudonative.lib/

		cd ../..
		echo_status "Creating fake rootdir-symlink."
		mkdir -p $( dirname ${xroot#/} )
		rm -f ${xroot#/}; ln -s / ${xroot#/}
	fi

	if [ ! -f proc/mounts ]; then
		mount -t proc proc $PWD/proc
	fi
	# A /dev with working PTYs is essential for make check in
	# binutils and gcc.
	if ! grep -q "$( pwd -P )/dev" /etc/mtab ; then
		mount --rbind /dev $PWD/dev
	fi

	cat > "$builddir/chroot.sh" <<- EOT
		#!/bin/bash
		export ROCK_THIS_IS_CHROOT=1; cd /ROCK
		./scripts/Build-Pkg $options -chr-sub -root "/" "$1"
	EOT

	cat > "$builddir/debug.sh" <<- EOT
		#!/bin/bash
		export ROCK_THIS_IS_CHROOT=1
		if [ ! -e $PWD/ROCK/loop/scripts ]; then
			mount --bind $realbase $PWD/ROCK/loop
			mount --bind $realconf $PWD/ROCK/config
			mount --bind $realdown $PWD/ROCK/download
		fi
		if [ ! -e $PWD/ROCK/src.$xpkg.$id ]; then
			ln -s loop/src.$xpkg.$id $PWD/ROCK/src.$xpkg.$id
		fi
		chroot "$xroot" /bin/bash /ROCK/src.$xpkg.$id/debug_x.sh
		rm -f $PWD/ROCK/src.$xpkg.$id
	EOT
	chmod +x "$builddir/debug.sh"

	if [ "$TZ" ] ; then
		if [ "${TZ#/}" != "$TZ" ] ; then
			cp $TZ ROCK/localtime
		else
			cp /usr/share/zoneinfo/$TZ ROCK/localtime
		fi
	else
		if [ -f /etc/localtime ] ; then
			cp /etc/localtime ROCK/localtime
		else
			ln -s /usr/share/zoneinfo/Factory ROCK/localtime
		fi
	fi

	TZ="/ROCK/localtime" chroot . bin/bash ROCK/src.$xpkg.$id/chroot.sh
	returncode=$?

	# Only remove $builddir if it is empty.
	rmdir --ignore-fail-on-non-empty "$realbase/src.$xpkg.$id"

	exit $returncode
fi

if [ "$ROCKCFG_FLIST" = "flwrapper" -a -z "$FLWRAPPER" ] ; then
	export FLWRAPPER_WLOG="$builddir/fl_wrapper.wlog"
	export FLWRAPPER_RLOG="$builddir/fl_wrapper.rlog"
	export FLWRAPPER_BASEPID=$$
	[ "$LD_PRELOAD" ] && LD_PRELOAD="${LD_PRELOAD}:"
	export FLWRAPPER="$base/build/$ROCKCFG_ID/ROCK/$toolsdir/lib/fl_wrapper.so"
	export LD_PRELOAD="${LD_PRELOAD}$FLWRAPPER"
fi
export INSTALL_WRAPPER_LOGFILE="$builddir/install_wrapper.log"
export CMD_WRAPPER_LOGFILE="$builddir/cmd_wrapper.log"

if [ $norebuild = 1 -a -f $root/var/adm/logs/$stagelevel-$xpkg.log ] ; then
	echo_pkg_deny $stagelevel $pkg "already built"
	exit 0
fi

if [ "$ROCKCFG_RETRY_BROKEN" = 0 -a $norebuild = 1 -a \
     -f $root/var/adm/logs/$stagelevel-$xpkg.err ] ; then
	echo_pkg_deny $stagelevel $pkg "already failed"
	exit 1
fi

confdir=""
archdir="$builddir/archdir"
if [ -z "$pkgdir" ] ; then
  for x in package/*/$pkg/$pkg.desc ; do
    if [ -f "$x" ] ; then
	if [ "$confdir" ] ; then
	    echo_pkg_deny $stagelevel $pkg "in multiple trees"
	    echo "Package in multiple trees: $pkg !" \
		> $root/var/adm/logs/$stagelevel-$xpkg.err
	    exit 1
	fi
	x=${x#package/}; x=${x%%/*}
	confdir="$base/package/$x/$pkg"
	repository=$x
    fi
  done
else
  if [ -f "$pkgdir/$pkg.desc" ] ; then
	confdir="$pkgdir"
	repository=extern
  fi
fi

if [ -z "$confdir" ] ; then
	echo_pkg_deny $stagelevel $pkg "does not exist" ; exit 1
fi

mkdir -p $root/var/adm/{logs,flists,cksums,md5sums,packages,dependencies}
mkdir -p $root/var/adm/{dep-debug,parse-config,cache,descs,rock-debug}
mkdir -p $root/var/adm/{provides,requires,conflicts}
[ "$root" ] && chmod 700 $root

rm -f $root/var/adm/logs/$stagelevel-$xpkg.{out,log,err}

if [ $this_is_the_2nd_run = 0 ] ; then
	options="-this_is_the_2nd_run $options $pkg=$xpkg"
	if [ "$ROCKCFG_CREATE_CACHE" = 1 -a $stagelevel -ge 3 ] ; then

		mkdir -p $root/var/adm/cache
		touch $root/var/adm/cache/$xpkg
		rm -f $root/var/adm/cache/$xpkg.tm

		/usr/bin/time -o "$root/var/adm/cache/$xpkg.tm" \
		    -f 'buildtime=$(qcalc %U + %S)' \
		    env -i HOME=$HOME TERM=$TERM PS1='\u:\w\$ ' PATH="$PATH" \
		    TZ="$TZ" ROCK_BUILD_TARGET=$ROCK_BUILD_TARGET \
		    build_root="$build_root" build_rock="$build_rock" \
		    build_logs="$build_logs" build_pkgs="$build_pkgs" \
		    ROCK_THIS_IS_CHROOT="$ROCK_THIS_IS_CHROOT" \
		    FLWRAPPER_WLOG="$FLWRAPPER_WLOG" FLWRAPPER_RLOG="$FLWRAPPER_RLOG" \
		    FLWRAPPER_BASEPID="$FLWRAPPER_BASEPID" FLWRAPPER="$FLWRAPPER" \
		    LD_PRELOAD="${LD_PRELOAD}" \
		    $0 $options
		returncode=$?
		[ ! -e "$root/var/adm/cache/$xpkg.tm" ] && exit $returncode

		qcalc() { gawk "BEGIN { printf(\"%d\n\", ($*)*100); }"; }
		eval "`grep -v '^Command ' < $root/var/adm/cache/$xpkg.tm`"
		rm -f $root/var/adm/cache/$xpkg.tm

		{
			errortag=""
			if [ -f "$root/var/adm/logs/$stagelevel-$xpkg.err" ] ; then
				errortag=" ERROR"
			fi

			if [ -f $confdir/$pkg.desc ] ; then
				grep '^\[COPY\] ' $confdir/$pkg.desc | \
					sed "s,/$pkg.desc\$,/$pkg.cache,"
			fi

			echo
			grep '^\[TIMESTAMP\]' $root/var/adm/cache/$xpkg
			date "+[TIMESTAMP] %s %c ($stagelevel)$errortag"

			echo
			echo "[CONFIG-ID] ${ROCKCFG_ID#*-}"
			echo -e "[ROCKVER] $rockver\n"

			echo "[LOGS]" $( cd $root/var/adm/logs ; \
					 ls ?-$xpkg.* 2> /dev/null )
			echo

			grep '^\[BUILDTIME\]' $root/var/adm/cache/$xpkg
			echo "[BUILDTIME] $buildtime ($stagelevel)$errortag"

			x="$root/var/adm/packages/$xpkg"
			if [ -f $x ]; then
				echo "[SIZE] `grep "^Package Size: " \
						$x | cut -f3- -d' '`"
			fi
			echo

			x="$root/var/adm/cache/$xpkg"
			if [ -f "$x" ]; then
				grep -e"\[DEP-[0-9]\]" "$x"
			fi
			x="$root/var/adm/dependencies/$xpkg"
			if [ "$pkg" != "rock-debug" -a -f $x ]; then
				cut -f2- -d' ' "$x" | \
					fmt -70 | sed "s,^,[DEP-$stagelevel] ,"
				cut -f2- -d' ' "$x" | \
					fmt -70 | sed 's,^,[DEP] ,'
				echo
			fi

			cat $root/var/adm/flists/$xpkg{,:*} 2> /dev/null | \
				sed -r '\,(bin/[^/]+|lib/.+\.(so|a))$, { s,.*/,,; p; };d' | \
				sort -u | fmt -w65 | sed 's,^,[PROVIDES] ,'
			echo

			for stagelevel in 0 1 2 3 4 5 6 7 8 9 ; do
				x="$root/var/adm/logs/$stagelevel-$xpkg.err"
				if [ -f "$x" ] ; then
					tail -n 50 "$x" | \
						sed "s,^,[$stagelevel-ERROR] ,"
					echo
				fi
			done
		} > $root/var/adm/cache/$xpkg.new
		mv $root/var/adm/cache/$xpkg.new $root/var/adm/cache/$xpkg

		exit $returncode
	else
		exec env -i HOME=$HOME TERM=$TERM PS1='\u:\w\$ ' PATH="$PATH" \
		    TZ="$TZ" ROCK_BUILD_TARGET=$ROCK_BUILD_TARGET \
		    build_root="$build_root" build_rock="$build_rock" \
		    build_logs="$build_logs" build_pkgs="$build_pkgs" \
		    ROCK_THIS_IS_CHROOT="$ROCK_THIS_IS_CHROOT" \
		    FLWRAPPER_WLOG="$FLWRAPPER_WLOG" FLWRAPPER_RLOG="$FLWRAPPER_RLOG" \
		    FLWRAPPER_BASEPID="$FLWRAPPER_BASEPID" FLWRAPPER="$FLWRAPPER" \
		    LD_PRELOAD="${LD_PRELOAD}" \
		    $0 $options
	fi
fi


#
# ----  Setting Build Variables
#

if [ -z "$root" ] ; then
	dummydir="$builddir/rootdummy"
else
	dummydir="${root}/ROCK/${builddir#$base/}/rootdummy"
fi

mkdir -p "$dummydir"

if [[ "$xpkg" = *-32bit ]] ; then
	instroot="$dummydir"
	libs_only=1
else
	instroot="$root"
	libs_only=0
fi

#
if [[ -z "$arch_target32" || "$xpkg" = *-32bit ]] ; then
	multilib="lib"
else
	multilib="lib64"
fi

flistroot="bin boot etc lib $multilib sbin usr var opt"
flistrfilter="ldconfig\..*:	.*|.*:	/var/adm/.*"
flistdel="var/adm/.*|var/tmp/.*|var/lock/.*|var/run/.*|etc/ld.so.cache|usr/tmp/.*|.*\\.old"

pkgsplits=""
if [ "$ROCKCFG_SPLIT_DEV" != 0 ]; then
	# this doesn't affect files in /lib, just /.../lib
	# so there needn't be an exception for linux kernel modules
	splitreg 40 dev "(/(lib|$multilib)/.*\.(la|a|o)\$|/include/|/man[23]/)"
	splitdesc_dev() { desc_I="$desc_I (development files)"; }
fi
if [ "$ROCKCFG_SPLIT_DOC" != 0 ]; then
	# only move doc/ to :doc, not man and info pages
	splitreg 60 doc '/share/doc/'
	splitdesc_doc() { desc_I="$desc_I (documentation)"; }
fi

makeopt='CC="$CC" CXX="$CXX"'
if [ $stagelevel -le 2 ] ; then
	var_append makeopt ' ' 'CC_FOR_BUILD="$BUILDCC"'
	var_append makeopt ' ' 'BUILDCC="$BUILDCC" BUILD_CC="$BUILD_CC"'
	var_append makeopt ' ' 'HOSTCC="$HOSTCC"   HOST_CC="$HOST_CC"'
	var_append makeopt ' ' 'STRIP="$STRIP" AR="$AR" LD="$LD"'
	var_append makeopt ' ' 'RANLIB="$RANLIB" NM="$NM"'
fi

makeinstopt="$makeopt install"
[ "$root" ] && var_append makeinstopt ' ' 'DESTDIR=$root'

if [ $stagelevel -ge 3 ] ; then
	flistdel="$flistdel|`echo $base | sed s,^/,,`/.*"
fi

prepare=""	; hook_add prepare	5 'eval "$prepare"'
prepatch=""	; hook_add prepatch	5 'eval "$prepatch"'
postpatch=""	; hook_add postpatch	5 'eval "$postpatch"'
postdoc=""	; hook_add postdoc	5 'eval "$postdoc"'
preconf=""	; hook_add preconf	5 'eval "$preconf"'
premake=""	; hook_add premake	5 'eval "$premake"'
inmake=""	; hook_add inmake	5 'eval "$inmake"'
postmake=""	; hook_add postmake	5 'eval "$postmake"'
postinstall=""	; hook_add postinstall	5 'eval "$postinstall"'
postflist=""    ; hook_add postflist    5 'eval "$postflist"'
finish=""	; hook_add finish	5 'eval "$finish"'

[ "$ROCKCFG_DO_CHECK" = 1 ] && hook_add inmake 6 'run_check'
hook_add postflist 3 'postflist_libs'

configprefix="" ; autogen=0 ; automakever=""
configscript="./configure" ; extraconfopt=""
configexec="bash"

srcdir=auto ; srctar=auto
taropt="--use-compress-program=bzip2 -xf"

mainfunction="build_this_package"
runconf=1 ; runxmkmf=1 ; runmkpl=1 ; runpysetup=1 ; runcmake=1 ; autopatch=1
autoextract=1 ; chownsrcdir=1 ; nocvsinsrcdir=1; patchopt="-bfp1 -z .orig"
createprefix=1 ; createdocs="" ; rmemptydir="" ; autoso2a=0 ; forcefpic=""
cmakesrcdir=.

check_shared=1
check_usrlocal=1
check_badfiles=1

badfiles="" badfiles_nr=0
declare -a badfiles_desc

#
# ---- Read various config files
#

parse_desc $confdir/$pkg.desc

ver="`echo "$desc_V" | tail -n 1 | cut -f1 -d' '`"
extraver="`echo "$desc_V" | tail -n 1 | cut -s -f2- -d' '`"
[ -z "$extraver" ] && extraver="0"

if [ "$pkg" = "$xpkg" ]; then
	echo_pkg_start $stagelevel $repository $xpkg $ver $extraver
else
	echo_pkg_start $stagelevel $repository $pkg=$xpkg $ver $extraver
fi

if [ "$ROCKCFG_PARANOIA_CHECK" = 1 -a -z "$pkgdir" ] ; then
        x="`./scripts/Check-PkgFormat $pkg`"
	[ "$x" ] && abort "$x\nDisable the 'Paranoia Check' config `
	                  `option to ignore such errors."
fi

targetdir="$base/target/$target"
patchfiles="`ls $confdir/*.patch $confdir/*.patch.$arch \
             $confdir/*.patch_$xpkg $confdir/*.patch_$xpkg.$arch \
             $targetdir/pkg_$pkg.patch $targetdir/pkg_$pkg.patch.$arch \
             $targetdir/xpkg_$xpkg.patch $targetdir/xpkg_$xpkg.patch.$arch \
             2>/dev/null | tr '\n' ' '`"

if [ $stagelevel -le 2 ]; then
	patchfiles="`ls $patchfiles $confdir/*.patch.cross \
	             $confdir/*.patch.cross.$arch 2>/dev/null | tr '\n' ' '`"
fi

if [ $stagelevel -le 1 -o "$ROCKCFG_CROSSBUILD" = 0 -a $stagelevel -eq 2 ] ; then
	createdocs=0
fi
if [ -f $confdir/$pkg.cache ]; then
	if ! egrep -q '^\[PROVIDES].*\.(so|a)( |$)' $confdir/$pkg.cache; then
		forcefpic="0"
	fi
fi
if [ $stagelevel -le 1 ] ; then
	var_append flistroot " " "$tools"
	flistdel="$flistdel|$tools/info/(dir|standards.info)"
else
	flistdel="$flistdel|$tools(/.*|)"
fi

if [ $stagelevel -ge 3 ]; then
	for pc_file in $xroot/var/adm/parse-config/* ; do
		if [ -s "$pc_file" -a "${pc_file##*/}" != "$xpkg" ]
		then . "$pc_file" ; fi
	done
	unset pc_file
fi

. $base/build/$ROCKCFG_ID/ROCK/$toolsdir/lib/parse-config

set_confopt

if [ $stagelevel -eq 0 -a "$ROCKCFG_PSEUDONATIVE" = 1 ]; then
	echo_status "Building this package statically for pseudo native build."
	var_insert extraconfopt " " "--enable-static --disable-shared"
	for x in BUILDCC_WRAPPER_INSERT LDFLAGS LD CFLAGS CC; do
		var_append $x " " "-static"
	done
fi

eval "$desc_O"

# include package pre config - if any
if [ -f $base/build/$ROCKCFG_ID/ROCK/$toolsdir/lib/pkg_${pkg}_pre.conf ] ; then
	echo_status "Reading build/.../$toolsdir/lib/pkg_${pkg}_pre.conf"
	. $base/build/$ROCKCFG_ID/ROCK/$toolsdir/lib/pkg_${pkg}_pre.conf
fi

if [ -f $targetdir/pkg_$pkg.conf ] ; then
	echo_status "Reading package configuration from target directory."
	. $targetdir/pkg_$pkg.conf

elif [ -f $confdir/$pkg.conf ] ; then
	echo_status "Reading package configuration from package directory."
	. $confdir/$pkg.conf
fi
# include package post config - if any
if [ -f $base/build/$ROCKCFG_ID/ROCK/$toolsdir/lib/pkg_${pkg}_post.conf ] ; then
	echo_status "Reading build/.../$toolsdir/lib/pkg_${pkg}_post.conf"
	. $base/build/$ROCKCFG_ID/ROCK/$toolsdir/lib/pkg_${pkg}_post.conf
fi

if [ -f $base/architecture/$arch/pkg-header ] ; then
	echo_status "Reading overwrites from architecture/$arch/pkg-header."
	. $base/architecture/$arch/pkg-header
fi

if [ -f $base/target/$target/pkg-header ] ; then
	echo_status "Reading overwrites from target/$target/pkg-header."
	. $base/target/$target/pkg-header
fi

#
# ---- Variable updates based on the configuration files read
#

if [ -z "$prefix" -o "${prefix#usr}" != "$prefix" ] ; then
	flistdel="$flistdel|usr/share/info/(dir|standards.info)"
	if [ "$ROCKCFG_DISABLE_NLS" = 1 ] ; then
		flistdel="$flistdel|usr/share/locale/..[/_].*"
		flistdel="$flistdel|usr/share/man/..[/_].*"
	fi
	if [ $stagelevel = 0 ] ; then
		flistdel="${flistdel//usr\//}|${flistdel//usr\/share\//}"
	fi
else
	flistdel="$flistdel|$prefix/info/(dir|standards.info)"
	if [ "$ROCKCFG_DISABLE_NLS" = 1 ] ; then
		flistdel="$flistdel|$prefix/share/locale/..[/_].*"
		flistdel="$flistdel|$prefix/man/..[/_].*"
	fi
fi

#
# ----  Build Package
#

echo_status "Preparing build in src.$xpkg.$id"

if [ "$ROCKCFG_SRC_TMPFS" = 1 ]; then
	echo_status "Mounting tmpfs on src.$xpkg.$id"
	mount -t tmpfs -o $ROCKCFG_SRC_TMPFS_OPT tmpfs "$builddir"
fi

if [ "$xroot" != "$root" ] ; then
	for x in $flistroot ; do
		[ -d $xroot/$x ] || mkdir -p $xroot/$x
		[ -d $root/$x  ] || ln -sf $xroot/$x $root/
	done
fi

if [ $update = 1 ] ; then
	echo_status "Creating backup of old package data (running in update mode)."
	(
		cd $xroot/
		grep -v "^X" var/adm/md5sums/$xpkg var/adm/md5sums/$xpkg:* 2> /dev/null |
			md5sum --check - 2>&1 | grep ': FAILED$' | cut -f1 -d:
	) > "$builddir/backup_files.txt"
	if [ -s "$builddir/backup_files.txt" ] ; then
		mkdir -p "$xroot/var/adm/backup"
		chmod 700 "$xroot/var/adm/backup"
		backup_tar="$xroot/var/adm/backup/$(
			date '+%Y%m%d%H%M%S')_$xpkg.tar.bz2"
		( cd $xroot/; tar --no-recursion --force-local -cf - -T "$builddir/`
			`backup_files.txt" || true; ) | bzip2 > $backup_tar
	else
		update=0
	fi
fi

if [ "$ROCKCFG_FLIST" = "flwrapper" ] ; then
	rm -f "$builddir/"fl_wrapper.{r,w}log
	touch "$builddir/"fl_wrapper.{r,w}log
elif [ "$ROCKCFG_FLIST" = "find" ] ; then
	touch "$builddir/temp.time_stamp"
	sleep 2
fi

if [ $stagelevel -gt 1 -a "$autoso2a" = 1 ]; then
	export AUTOSO2A_DIR="$builddir/autoso2a"
	export AUTOSO2A_AR="$AR" AUTOSO2A_RANLIB="$RANLIB"
	var_insert CC_WRAPPER_OTHERS ":" "so2a_wrapper"
	var_insert CXX_WRAPPER_OTHERS ":" "so2a_wrapper"
fi

i=0
mkdir -p "$builddir/wrappers"
for x in "${wrapper_data[@]}"; do
	echo "$x" | (
		read n; o="$n"
		if [ -f "$builddir/wrappers/$n" ]; then
			mv "$builddir/wrappers/$n" "$builddir/wrappers/$n.$i"
			o="$n.$i"; (( i++ ))
		fi
		{
			echo '#!/bin/bash'
			echo 'echo "$PWD: $0 $*" >> "'"$builddir/wrappers.log"'"'
			echo 'PATH="$PATH_WRBACKUP"'
			echo "orig='$o'"
			cat
		} > "$builddir/wrappers/$n"
		chmod +x "$builddir/wrappers/$n"
	)
done
export PATH_WRBACKUP="$PATH"
PATH="$builddir/wrappers:$PATH"
unset i

# make sure we don't create an flist with just an
# empty docdir in it if the package build fails..
flistdel="$flistdel|${docdir#$root/}"

# define new abort function for errors while building
#
abort() {
	[ "$*" ] && echo "$*"; echo "--- BUILD ERROR ---"
	rm -vf $root/var/adm/logs/$stagelevel-$xpkg.log
	false
}

# FD 202 can be used to write output to console instead of build log
exec 202>&1

{
    (
	set -e
	set +h

	echo "Build-Pkg exec $PATH"
	
	echo -e "\n--- ENVIRONMENT Variables ---"
	set | grep "^[^ ]*="
	echo -e "--- ENVIRONMENT Variables ---\n"

	if [ $xtrace -eq 1 -o $ROCKCFG_XTRACE -eq 1 ] ;	then
		PS4=$'=[$FUNCNAME:$LINENO (last \\\$?=$?)> '
		set -o xtrace
	fi

	trap 'echo "Got SIGINT (Crtl-C). Aborting build." ; exit 1' INT
	exec < /dev/null

	mkdir -p "$builddir/archdir"

	# Download archives files and link to them in $archdir.
	while read l_cksum l_srctar l_url l_flags ; do
		[ -z "$l_cksum" ] && continue
		x=`source_file l_cksum $l_srctar l_url $l_flags`
		if [ ! -f $x ]; then
			if [ $download = 1 ] ; then
				echo_status "Running ./scripts/Download for this package..."
				echo_status "----- DOWNLOAD LOG -----"
				echo; ./scripts/Download $xpkg; echo
				echo_status "------------------------"
				download=0
			fi >&202 2>&1
			if [ ! -f $x ]; then
				echo "File not found: ${x#$base/}"
				abort "Did you run ./scripts/Download for this package?"
			fi
		fi
		ln -vs $x "$builddir/archdir/"
	done < <( echo "$desc_D" | column_clean )

	hook_eval prepare

	echo_status "Building. Writing output to" \
	            "\$root/var/adm/logs/$stagelevel-$xpkg.out" >&202

	# Makes debugging build problems easier
	#
	hook_dump > "$builddir/debug.hooks"
	#
	{
	  dump_env
	  cat <<- EOT
		PS1='\\[\\e[00m\\e[01;31m\\]debug-`
					`$xpkg\\[\\e[00m\\]:[\\W]\\\$ '
		alias cp="cp -i" ; alias mv="mv -i"
		alias rm="rm -i" ; alias ls="ls --color=auto -a"
		alias ..="cd .." ; alias ...="cd ../.."
		alias xdiff="sh $base/misc/archive/xdiff.sh"
		alias bked="sh $base/misc/archive/bked.sh"
		fixfile () {
		  # we use .vanilla to not rediff backup .orig from patch
		  [ -f \$1.vanilla ] || cp \$1 \$1.vanilla
		  \$EDITOR \$1
		}
		fixfilediff() {
		  find -name '*.vanilla' | while read x ; do
		    diff -u \$x \${x/.vanilla/}
		  done
		}
		EOT
	} > "$builddir/debug.buildenv"
	#
	cat > "$builddir/debug_x.sh" <<- EOT
		#!/bin/bash
		# export PROMPT_COMMAND='. debug.buildenv; cd .; unset PROMPT_COMMAND'
		cd "$root"
		if [ -e $PWD/ROCK ]; then
			if [ ! -e $PWD/ROCK/loop/scripts ]; then
				mount --bind $realbase $PWD/ROCK/loop
				mount --bind $realconf $PWD/ROCK/config
				mount --bind $realdown $PWD/ROCK/download
			fi
			if [ ! -e $PWD/ROCK/src.$xpkg.$id ]; then
				ln -s loop/src.$xpkg.$id $PWD/ROCK/src.$xpkg.$id
			fi
		fi
		cd "$builddir" ; exec env -i bash --init-file debug.buildenv 200>> build.pid
	EOT
	#
	if [ "$ROCK_THIS_IS_CHROOT" != 1 ]; then
		mv "$builddir/debug_x.sh" "$builddir/debug.sh"
		chmod +x "$builddir/debug.sh"
	fi

	# Create PID file
	#
	# The builtin variable '$$' is not this pid because this proc
	# is just a sub-proc of $$. That's why the $builddir/strace.tmp
	# hack is required to get the right pid to trace.
	#
	# We also connect file descriptor 3 with the pid file. So the command
	# 'fuser' can be used to create a list of all processes which are part
	# of this build process.
	#
	sh -c 'echo $PPID' > "$builddir/build.pid"
	exec 200>> "$builddir/build.pid"

	echo "Command Wrapper Debug: running '${CC} --version' .."
	type ${CC%% *}; CMD_WRAPPER_DEBUG=1 ${CC} --version
	echo "[ writing debug log to $builddir/cmd_wrapper.log ]"

	if [ "$debug" = 1 ] ; then
		echo "Everything is set up." \
		     "We are in debug mode - so exit now."
		exit
	fi

	if [ "$ROCKCFG_FLIST" = "strace" ] ; then
		if [ "$(uname -m)" = "ppc" ]; then
			SYSEXIT="exit"
		else
			SYSEXIT="_exit"
		fi
		strace -o "$builddir/strace.out" -F -f -q -e open,creat,mkdir,`
		       `mknod,link,symlink,rename,utime,chdir,execve,`
                       `fork,clone,vfork,`
                       `$SYSEXIT,exit_group -p `cat "$builddir/build.pid"` &
                 strace_pid=$! ; sleep 1 ; cd $base
	fi

	echo "Running main build function '$mainfunction' ..."
	cd "$builddir" ; eval "$mainfunction"

	hook_eval postinstall

	echo "Creating file list and doing final adaptions ... "
	#
	cd $xroot/
	#
	if [ "$ROCKCFG_FLIST" = "strace" ] ; then
		sleep 1 ; kill -INT $strace_pid ; sleep 1
		fl_stparse -w "$builddir/fl_wrapper.wlog" \
			   -r "$builddir/fl_wrapper.rlog" < "$builddir/strace.out"
		
	fi
	if [ "$ROCKCFG_FLIST" = "flwrapper" -o \
	     "$ROCKCFG_FLIST" = "strace" ] ; then
		if [ "$stagelevel" -le 2 ]
		then
			xbase="$( cd $xroot/ 2> /dev/null ; pwd -P )"

			egrepexp="[	 ]($base|$xbase|$builddir|/tmp|/usr/lib/(conftest|cf)[0-9]*|/usr/tmp|/var/tmp|/var/backups|/proc|/dev)(/|$)"
			if cat $builddir/fl_wrapper.wlog | sed 's,//*,/,g' | \
				egrep -qv "$egrepexp"
			then
				x="Created file outside basedir: "
				cat $builddir/fl_wrapper.wlog | sed 's,//*,/,g' | \
					egrep -v "$egrepexp" | cut -f2- | \
					sort -u | sed "s,^,$x,"
				echo "base #1: $base"
				echo "base #2: $xbase"
				abort
			fi
		fi
		if fl_wrparse -D -s -r "$xroot/" < $builddir/fl_wrapper.wlog | \
			egrep "^(${flistroot// /|})(/|$)" >> \
			$builddir/flist.txt
		then : ; fi
	elif [ "$ROCKCFG_FLIST" = "find" ] ; then
		if find $flistroot \
			\( -not -type d -or -type d -empty \) \
			-and \( -newer $builddir/temp.time_stamp -or \
			-cnewer $builddir/temp.time_stamp \) -printf "%p\n" >> \
			$builddir/flist.txt
		then : ; fi
	fi

	# evaluate flistdel (1/2)
	egrep -v "^($flistdel)\$" $builddir/flist.txt | sort -u > $builddir/flist.txt.new
	mv $builddir/flist.txt.new $builddir/flist.txt

	# copy over missing *.a files
	if [ "$autoso2a" = 1 ]; then
		echo "Checking for missing .a files ..."
		while read d s; do
			grep -q "/${s%.so}.a$" $builddir/flist.txt && continue
			[ "$d" = "lib" ] && d="usr/lib"
			if [ -f "$AUTOSO2A_DIR/${s%.so}.a" ]; then
				echo "Installing automatically created $d/${s%.so}.a."
				cp "$AUTOSO2A_DIR/${s%.so}.a" "$root/$d/${s%.so}.a"
				add_flist "$root/$d/${s%.so}.a"
			else
				echo "Not found: $AUTOSO2A_DIR/${s%.so}.a"
			fi
		done < <( egrep '(^|/)lib/[^/]*\.so$' "$builddir/flist.txt" | sed 's,\(.*\)/,\1 ,' )
	fi

	# merge flist of previous build
	for x in var/adm/flists/$xpkg var/adm/flists/$xpkg:*; do
		[ -f $x ] && cut -f2- -d' ' $x >> "$builddir/flist.txt"
	done

	# evaluate flistdel (2/2)
	egrep -v "^($flistdel)\$" "$builddir/flist.txt" | sort -u > "$builddir/flist.txt.new"
	mv "$builddir/flist.txt.new" "$builddir/flist.txt"

	hook_eval postflist

	fl_wrparse -D -p "$xpkg" -r "$xroot/" < "$builddir/flist.txt" | sort -u > "$builddir/flist.split"
	echo Found `wc -l < "$builddir/flist.split"` "files for this package."
	splitapply $xpkg "$builddir/flist.split"

	if [ "$ROCKCFG_FLIST" = "flwrapper" -o \
	     "$ROCKCFG_FLIST" = "strace" ] && [ $stagelevel -ge 3 ] ; then
		echo "Calculating build-time package dependencies ..."

		! egrep -v "^($flistrfilter)\$" "$builddir"/fl_wrapper.[rw]log |
		sort -u | fl_wrparse -D -s -r "$xroot/" -p '' | \
		grep -v ' var/adm/' | awk '
			ARGIND < ARGC-1 {
			    if ( index($1, "'$xpkg':") != 1 )
				f[$2] = $1 " " f[$2];
			}
			ARGIND == ARGC-1 {
			    file = $2;
			    while ( file != "" ) {
				if ( f[file] ) {
				    split(f[file], a);
				    for (i in a)
					if (! d[a[i] " " file]) {
					    d[a[i] " " file] = 1;
					    print a[i] " " file;
					}
				}
				sub("/?[^/]*$", "", file)
			    }
			}
		' var/adm/flists/* - > "$builddir/dependencies.debug"

		awk 'BEGIN { FS=": "; } { print "'$xpkg': " $1; }' \
			<  "$builddir/dependencies.debug" > "$builddir/dependencies.txt"

		if [ -f var/adm/dep-debug/$xpkg ] ; then
			cat var/adm/dep-debug/$xpkg >> "$builddir/dependencies.debug"
		fi
		sort -u "$builddir/dependencies.debug" > var/adm/dep-debug/$xpkg

		# add debug info for known false dependencies
		if egrep -q "^[^#].* $xpkg( |$)" $base/scripts/dep_fixes.txt; then
			echo "---  $xpkg [$stagelevel] ---" >> $root/var/adm/rock-debug/falsedeps.txt
		fi
		while read x; do
			grep "^$x: " "$builddir/dependencies.debug" | sort -u | \
				sed "s,:, -> $xpkg [$stagelevel]:," >> $root/var/adm/rock-debug/falsedeps.txt
		done < <( egrep "^$xpkg +del +" $base/scripts/dep_fixes.txt | \
				tr ' ' '\t' | tr -s '\t' | cut -f3- | tr '\t' '\n' )

		# merge the dependencies defined by the package
		for x in `echo "$desc_E" | egrep '^add ' | sed 's/^add //' ` ; do
			echo "Adding dependency: $x ..."
			echo "$xpkg: $x" >> "$builddir/dependencies.txt"
		done

		# remove dependencies as requested by the package
		# TODO: groups are not used yet (and it is not easy here)
		del_pattern=""
		for x in `echo "$desc_E" | egrep '^del ' | sed 's/^del //' ` ; do
			del_pattern="$del_pattern -e \".*: $x(:.*|)\$\""  
		done
		if [ -n "$del_pattern" ] ; then
			echo "Deleting dependencies, pattern: $del_pattern ..."
			eval "egrep -v $del_pattern \"$builddir/dependencies.txt\"" > "$builddir/dependencies.txt.new"
			mv "$builddir/dependencies.txt.new" "$builddir/dependencies.txt"
		fi

		if [ -f var/adm/dependencies/$xpkg ] ; then
			cat var/adm/dependencies/$xpkg >> "$builddir/dependencies.txt"
		fi
		sort -u "$builddir/dependencies.txt" > "$builddir/dependencies.txt.new"
		mv "$builddir/dependencies.txt.new" "$builddir/dependencies.txt"
	fi

	echo "Calculating run-time package dependencies from pkg-config files..."
	grep "\.pc$" "$builddir/flist.split" | while read dummy x ; do
		x="$root/$x"

		# Only three tags are of interest here. Version: is mandatory.
 		version="`grep -e"^Version:" $x | cut -f2- -d' '`"
		[ "$version" ] || continue

		# Set the variables defined in the .pc file.
		eval $( sed 's,^\([a-zA-Z0-9_]*\)=\(.*\),\1="\2",p ; d' $x )

		echo "`basename ${x%.pc}` $version" >> $builddir/provides.tmp
		for tag in Requires Conflicts ; do
			case "$tag" in
				"Requires")	tmpfile="$builddir/requires.tmp" ;;
				"Conflicts")	tmpfile="$builddir/conflicts.tmp" ;;
			esac
			# Set positional parameters to the tag values.
			set $( sed -e"/^$tag: / { s,^$tag: ,, ; s/,/ /g ; p } ; d" $x ) ""

			while [ "$1" ] ; do
				eval echo -n "$1"
				case "$2" in
					"<"|">"|"<="|">="|"=")
						echo " $2 $3" ; shift 2 ;;
					*) 	echo ;;
				esac ; shift
			done >> $tmpfile
		done
	done

	for spkg in $( sed 's,: .*,,' < "$builddir/flist.split" | sort -u )
	do
	  (
		if [ -z "${spkg##*:*}" ]; then
			splitdesc_${spkg#*:}
		fi

		echo "<$spkg> Calculating run-time package dependencies from ELF files..."
		grep "^$spkg: " "$builddir/flist.split" | while read dummy x ; do
			x="$root/$x"

			# Symbolic links (to ELF files) and non-regular files
			# are ignored.
			[ -L "$x" -o ! -f "$x" ] && continue

			# Strip most values from ELF dynamic and version
			# sections as they don't contain useful info.
			readelf -dV $x 2>/dev/null | sed -e '
			/^Version definition section /,/^Version needs section / {
				s,.* Flags: BASE .* Name: \(.*\),provides \1,p
			}
			/^Version needs section /,$ {
				s,.* File: \([^ ]*\) .*,requires \1,p
			}
			# in dynamic section
			s,.* (SONAME) .* Library soname: \[\(.*\)\]$,provides \1,p
			s,.* (NEEDED) .* Shared library: \[\(.*\)\]$,requires \1,p
			# in version sections
			s,.* Name: \([^ ]*\).*,\1,p ; d
			' | while read a b ; do
				case "$a" in
					"provides"|"requires")
						pref="$b" ; tmpfile="$builddir/$a.tmp"
						[ "$a" == provides ] && cmp_op=" " || cmp_op=" @ "
						echo "$pref" >> $tmpfile ;;
					*)	echo "$pref${cmp_op}$a" >> $tmpfile ;;
				esac
			done
		done

		for x in {provides,requires,conflicts} ; do
			if [ -f "$builddir/$x.tmp" ] ; then
				echo "<$spkg> Creating var/adm/$x/$spkg"
				sort -u "$builddir/$x.tmp" > var/adm/$x/$spkg
				rm -f "$builddir/$x.tmp"
			else
				rm -f var/adm/$x/$spkg
			fi
		done

		echo "<$spkg> Creating flist file ..."
		{
			grep "^$spkg: " "$builddir/flist.split"
			for x in var/adm/{parse-config,provides,requires,conflicts}/$spkg ; do
				[ -s "$x" ] && echo "$spkg: $x"
			done
			for x in var/adm/{flists,md5sums,cksums,packages,descs,dependencies}/$spkg ; do
					touch $x ; echo "$spkg: $x"
			done
		} | sort -u > var/adm/flists/$spkg

		if [ -f "$builddir/dependencies.txt" ] ; then
			echo "<$spkg> Creating package dependencies file ..."
			sed "s,^[^ ]*,$spkg:," < "$builddir/dependencies.txt" > var/adm/dependencies/$spkg
		fi

		echo "<$spkg> Creating package description ..."
		#
		rocksrcck=$(cd $base; md5sum package/*/$pkg/* 2> /dev/null | \
					grep -v '\.cache$' | md5sum | cut -f1 -d' ')
		buildlist="$( grep "^Build \[.\] at " var/adm/packages/$spkg || true
			echo "Build [$stagelevel] at $buildstart to `date "+%T %Z"`")"
		#
		cat > var/adm/packages/$spkg << EOT
Package Name and Version: $spkg $ver $extraver
Package Size: `getdu $root/ < var/adm/flists/$spkg`, `
				wc -l < var/adm/flists/$spkg | tr -d ' '` files
ROCK Linux Package Source Checksum: $rocksrcck
ROCK Linux Version and Architecture: $rockver $arch
Build on `uname -m -n -r -s -p`
$buildlist
Status: ${desc_S:-ALPHA},  License: ${desc_L:-Unknown}

  ${desc_I:-$spkg}

$( echo "${desc_T:-No description available.}" | sed 's,^,  ,' )

URL(s):
$( echo "${desc_U:-http://www.rocklinux.net/packages/$pkg.html}" | sed 's,^,  ,' )

Original Author(s):
$( echo "${desc_A:-Unknown}" | sed 's,^,  ,' )

ROCK Package Maintainer(s):
$( echo "${desc_M:-Unknown}" | sed 's,^,  ,' )

Download URL(s):
$( echo "${desc_D:-None}" | awk '{ print "  " $3 $2; }' )
EOT
		{
		    echo "[CONFIG] ${ROCKCFG_ID#*-}"
		    while read x; do
			if [ "${x#\[}" != "$x" ]; then # "]}"
			    x="`echo ${x// /|} | tr -d '[]'`"
			    y="${x%%|*}" ; x="(${x%|(*)})"
			    case "$y" in
				V) echo "[V] $ver $extraver" ;;
				*) echo "$descfile" | egrep "^\[$x\]" | expand | sed "s,^[^ ]*,[$y]," ;;
			    esac
			fi
		    done < $base/Documentation/Developers/PKG-DESC-FORMAT
		} > var/adm/descs/$spkg

		# Create them last so checksums of other var/adm files are correct.
		echo "<$spkg> Creating md5sum and cksum files ..."
		echo -n > var/adm/cksums/$spkg
		echo -n > var/adm/md5sums/$spkg
		# getfiles only returns non-directories, suitable for checksum creation.
		getfiles < var/adm/flists/$spkg > "$builddir/files.lst"
		if [ -s "$builddir/files.lst" ] ; then
			while read file ; do
				[ -z "${file//[ 	]/}" ] && continue
				# Checksums on these files are volatile.
				if [ "$file" = "var/adm/cksums/$spkg" -o \
				    "$file" = "var/adm/md5sums/$spkg" -o \
				    -b "$file" -o -c "$file" -o -p "$file" -o \
				    -L "$file" -o -S "$file" ] ; then
					echo "X ${file}" >> var/adm/md5sums/$spkg
					echo "X $( stat -c %s ${file} ) ${file}" \
					    >> var/adm/cksums/$spkg
				elif [ ${ROCKCFG_CREATE_CKSUM} -eq 1 ] ; then
					md5sum "${file}" >> var/adm/md5sums/$spkg
					cksum  "${file}" >> var/adm/cksums/$spkg
				else
					echo "0 ${file}" >> var/adm/md5sums/$spkg
					echo "0 $( stat -c %s ${file} ) ${file}" \
					    >> var/adm/cksums/$spkg
				fi
			done < "$builddir/files.lst"
		fi

		if [ $stagelevel -ge 3 -a $nopostinst = 0 -a -d /var/adm/postinstall ]; then
			cp var/adm/flists/$spkg "$(mktemp var/adm/postinstall/${spkg}-install.XXXXXX)"
		fi
	  )
	done

	echo "Making post-install adaptions."
	if [ $stagelevel -ge 3 -a -f /sbin/ldconfig ] ; then ldconfig ; fi

	if [ "$ROCKCFG_PARANOIA_CHECK" = 1 ] ; then
		found_errors=0
		found_dups=0

		# check for files which are 'shared' with other packages
		if [ "$check_shared" != "0" ]; then
			while read dummy file; do
				if [ $found_dups = 0 ] ; then
					echo "Found shared files with other packages:"
					found_errors=1; found_dups=1
				fi
				echo "$file:" $( cd $root/var/adm/flists
						 grep -l " $file\$" * )
			done < <( find $root/var/adm/flists/ -maxdepth 1 -type f | \
				  xargs -n100 sed "s,^$xpkg:[^ ]*,.," | \
				  sort -k2 | uniq -d -f1 | grep '^\. ' )
		fi

		found_local=0

		# check for files in /usr/local
		if [ "$check_usrlocal" != "0" ]; then
			while read file ; do
				if [ $found_local = 0 ] ; then
					echo "Found files in /usr/local:"
					found_errors=1; found_local=1
				fi
				echo $file
			done < <( sed "s,^$xpkg: ,/," $root/var/adm/flists/$xpkg \
					$root/var/adm/flists/$xpkg:* 2> /dev/null | egrep "^/usr/local" )
		fi

		found_bad=0

		# check for registered 'bad files'
		if [ "$check_badfiles" != "0"  -a -n "$badfiles" ]; then
			echo "$badfiles" > "$builddir/badfiles.txt"
			while read x file; do
				if [ $found_bad = 0 ]; then
					echo "Found registered 'bad files' in package:"
					found_errors=1; found_bad=1
				fi
				desc="No description found!"
				for ((x=0; x<badfiles_nr; x++)); do
					if echo " $file" | grep -q "${badfiles_desc[x]%%$'\n'*}" 
					then desc="${badfiles_desc[x]#*$'\n'}"; fi
				done
				echo "$file: $desc"
			done < <( grep -f "$builddir/badfiles.txt" $root/var/adm/flists/$xpkg \
					$root/var/adm/flists/$xpkg:* 2> /dev/null )
		fi

		[ $found_errors != 0 ] && abort
	fi
	touch $root/var/adm/logs/$stagelevel-$xpkg.log

	echo "Finished building $pkg=$xpkg."
	hook_eval finish
    )

    if [ ! -f $root/var/adm/logs/$stagelevel-$xpkg.log ] ; then
	abort
    fi

} 2>&1 | {
	trap '' INT

	if [ "$ROCKCFG_VERBOSE" = 1 -o "$verbose" = 1 ] ; then
		tee $root/var/adm/logs/$stagelevel-$xpkg.out
	else
		cat > $root/var/adm/logs/$stagelevel-$xpkg.out
	fi
}

if [ $update = 1 ] ; then
	echo_status "Restoring backup of old package data."

	while read fn ; do
		[ -f $xroot/$fn ] && mv $xroot/$fn $xroot/$fn.new
	done < "$builddir/backup_files.txt"

	tar --force-local --use-compress-program=bzip2 -C $xroot/ -xpf $backup_tar

	while read fn ; do
		cmp -s $fn $fn.new && rm -f $fn.new
	done < "$builddir/backup_files.txt"
fi

cd $base

umount -r -d -f    "$builddir"/* 2> /dev/null
umount -r -d -f -l "$builddir"/* 2> /dev/null

if [ "$ROCKCFG_SRC_TMPFS_LOG" = 1 -a -n "$( type -p df )" ]; then
	if [ ! -f $root/var/adm/rock-debug/tmpfslog.txt ] ; then
		echo -e "# Config\tPackage\tInodes\tKB" | \
			expand -t20 > $root/var/adm/rock-debug/tmpfslog.txt
	fi
	echo -e "$config\t$stagelevel-$xpkg\t$(
		df 2> /dev/null -Pi "$builddir" | tail -n 1 | tr -s ' ' | cut -f3 -d' '
	)\t$(
		df 2> /dev/null -Pk "$builddir" | tail -n 1 | tr -s ' ' | cut -f3 -d' ')" | \
	expand -t20 >> $root/var/adm/rock-debug/tmpfslog.txt
fi

if [ "$ROCKCFG_PSEUDONATIVE" = 1 -a $stagelevel -eq 0 ]; then
	rm -f $base/build/$ROCKCFG_ID/pseudonative_handler
fi

if [ "$ROCKCFG_FLIST" = "flwrapper" ] ; then
	export LD_PRELOAD="${LD_PRELOAD//${FLWRAPPER}/}"
	export LD_PRELOAD="${LD_PRELOAD//::/:}"
fi

if [ "$ROCKCFG_SRC_TMPFS" = 1 ]; then
	umount -l "$builddir"
fi

if [ -f $root/var/adm/logs/$stagelevel-$xpkg.log ] ; then
	if [ $clear_src = 1 ] ; then
		rm -rf "$builddir"/* "$builddir"
	else
		cp $root/var/adm/logs/$stagelevel-$xpkg.out "$builddir/BUILD-LOG"
	fi
	echo_status "\$root/var/adm/logs/$stagelevel-$xpkg.out" \
	            "-> $stagelevel-$xpkg.log"
	mv $root/var/adm/logs/$stagelevel-$xpkg.out \
		$root/var/adm/logs/$stagelevel-$xpkg.log
	echo_pkg_finish $stagelevel $repository $xpkg
	exit 0
else
	if [ $clear_src = 1 -a "$ROCKCFG_ALWAYS_CLEAN" = 1 ] ; then
		rm -rf "$builddir"/* "$builddir"
	else
		cp $root/var/adm/logs/$stagelevel-$xpkg.out "$builddir/ERROR-LOG"
	fi
	if [ "$ROCKCFG_VERBOSE" != 1 -a "$verbose" != 1 ] ; then
		echo_errorquote "$( grep -B7 -- '--- BUILD ERROR ---' \
			$root/var/adm/logs/$stagelevel-$xpkg.out | \
			sed '$ s,--- BUILD ERROR ---,,' | \
			grep . | grep -vx -- -- )"
	fi
	echo_status "\$root/var/adm/logs/$stagelevel-$xpkg.out" \
	            "-> $stagelevel-$xpkg.err"
	mv $root/var/adm/logs/$stagelevel-$xpkg.out \
		$root/var/adm/logs/$stagelevel-$xpkg.err
	echo_pkg_abort $stagelevel $repository $xpkg
	exit 1
fi

# ----  EOF
