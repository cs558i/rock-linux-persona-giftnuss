#!/bin/bash
# --- ROCK-COPYRIGHT-NOTE-BEGIN ---
# 
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# Please add additional copyright information _after_ the line containing
# the ROCK-COPYRIGHT-NOTE-END tag. Otherwise it might get removed by
# the ./scripts/Create-CopyPatch script. Do not edit this copyright text!
# 
# ROCK Linux: rock-src/scripts/config.func
# ROCK Linux is Copyright (C) 1998 - 2006 Clifford Wolf
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version. A copy of the GNU General Public
# License can be found at Documentation/COPYING.
# 
# Many people helped and are helping developing ROCK Linux. Please
# have a look at http://www.rocklinux.org/ and the Documentation/TEAM
# file for details.
# 
# --- ROCK-COPYRIGHT-NOTE-END ---

# This function appends or inserts values to a variable:
#
#       var_append PATH ":" "$HOME/bin"
#       var_insert PATH ":" "$HOME/bin"
#
var_append() {
        eval "[ \"\$$1\" ] && $1=\"\${$1}$2\""
        eval "$1=\"\${$1}$3\""
}
var_insert() {
        eval "[ \"\$$1\" ] && $1=\"$2\$$1\""
        eval "$1=\"$3\$$1\""
}

# Functions for working with $swpdir/packages
#
#	pkgenable	package-list
#	pkgdisable	package-list
#	pkgremove	package-list
#	pkgcheck	pattern X|O|.
#	pkgfilter	cmd arg1 ...
#

if [ -n "$nobashmod" ]
then
	pkgin() { :; }
	pkgout() { :; }
	__pkgfilter() {
		"$@" < $swpdir/packages > $swpdir/packages.new
		mv $swpdir/packages.new $swpdir/packages
	}
	pkgfilter() {
		bprof pkgfilter start
		__pkgfilter "$@"
		bprof pkgfilter stop
	}
	pkgenable() {
		bprof pkgenable start
		local pattern patterns
		for pattern; do
			patterns="$patterns /[ =]$pattern / s,^O,X, ;"
		done
		if [ "$patterns" ]; then
			__pkgfilter sed -e "$patterns"
		fi
		bprof pkgenable stop
	}
	pkgdisable() {
		bprof pkgdisable start
		local pattern patterns
		for pattern; do
			patterns="$patterns /[ =]$pattern / s,^X,O, ;"
		done
		if [ "$patterns" ]; then
			__pkgfilter sed -e "$patterns"
		fi
		bprof pkgdisable stop
	}
	pkgremove() {
		bprof pkgremove start
		local pattern patterns
		if [ "$1" ]; then
			patterns="/ $1 / d ;"; shift
			for pattern; do
				patterns="$patterns / $pattern / d ;"
			done
			__pkgfilter sed -e "$patterns"
		fi
		bprof pkgremove stop
	}
	pkgcheck() {
		bprof pkgcheck start
		local pattern="$1" stat="$2"

		sed -n -e "/^$stat.*[ =]${pattern} / q0 ; $ q1 ;" \
			< $swpdir/packages
		local ret=$?
		bprof pkgcheck stop
		return $ret
	}
	#
	# pkgfork <origpkg> <newpkg> <name1> <value1> <name2> <value2> ..
	#
	# Names:
	#	status		X / O
	#	stages		012--5---9
	#	priority	115.000
	#	version		0.9.26
	#	prefix		/opt/foobar
	#	flag		CORE
	#	unflag		CORE
	#
	pkgfork() {
		local pkg=$1 xpkg=$2 script ; shift 2

		parse_desc package/*/$pkg/$pkg.desc P V

		extraver=$( echo $desc_V 0 | cut -f2 -d" " )

		script="\$5==\"$pkg\" {print; \$1=\"${desc_P%% *}\"; \
			\$2=\"$( echo $desc_P | cut -f2 -d" ")\"; \
			\$3=\"${desc_P##* }\"; \$5=\"$pkg=$xpkg\"; \
			\$6=\"${desc_V%% *}\"; \$7=\"$extraver\";"

		while [ -n "$1" ]; do
			case "$1" in
				status)
					script="$script \$1=\"$2\";"
					;;
				stages)
					script="$script \$2=\"$2\";"
					;;
				priority)
					script="$script \$3=\"$2\";"
					;;
				version)
					script="$script \$6=\"$2\";"
					;;
				extraversion)
					script="$script \$7=\"$2\";"
					;;
				flag)
					script="$script sub(\" 0\$\", \" $2 0\");"
					;;
				unflag)
					script="$script sub(\" $2 \", \" \");"
					;;
			esac
			shift 2
		done
		script="$script} {print;}"
		pkgfilter "awk" "--" "$script"
	}
else
	pkgin() { cfghlp pkg_in $swpdir/packages; }
	pkgout() { cfghlp pkg_out $swpdir/packages ; }
	pkgfilter() {
		bprof pkgfilter start
		cfghlp pkg_out $swpdir/packages.tmp
		"$@" < $swpdir/packages.tmp > $swpdir/packages
		cfghlp pkg_in $swpdir/packages
		bprof pkgfilter stop
	}
	pkgenable() {
		bprof pkgenable start
		cfghlp pkgenable "$@"
		bprof pkgenable stop
	}
	pkgdisable() {
		bprof pkgdisable start
		cfghlp pkgdisable "$@"
		bprof pkgdisable stop
	}
	pkgremove() {
		bprof pkgremove start
		cfghlp pkgremove "$@"
		bprof pkgremove stop
	}
	pkgcheck() {
		bprof pkgcheck start
		cfghlp pkgcheck "$1" "$2"; local ret=$?
		bprof pkgcheck stop
		return $ret
	}
	pkgfork() {
		local pkg=$1 xpkg=$2 status priority stages version extraver; shift 2

		bprof pkgfork start

		local parser="$( type -p descparser )" tag tagdata

		[ -z "${parser}" ] && parser="$base/src/descparser"
		if [ ! -x "${parser}" ] ; then
			mkdir -p $base/src
			cc -o $base/src/descparser $base/misc/tools-source/descparser.c
		fi
		[ ! -x "${parser}" ] && abort "Couldn't find \`descparser'! Please run ./scripts/Build-Tools!"

		read status priority stages version extraver < <( pkg=$pkg xpkg=$xpkg $parser -x < package/*/$pkg/$pkg.desc )

		cfghlp pkgfork $pkg $xpkg status "$status" priority "$priority" \
			stages "$stages" version "$version" extraversion "$extraver" "$@"

		bprof pkgfork stop
	}
fi

comment() {
	local text="$1" help="$2"
	bprof comment start
	if [ "$ROCKCFG_EXPERT" -eq 1 -o $expert -eq 0 ]
	then
		commentnr=$(( $commentnr + 1 ))
		echo "COMMENT_$commentnr '$spacer$text'" >> $swpdir/config.dialog.$menu_this

		set_help "COMMENT_$commentnr" "$help"
	fi
	bprof comment stop
}

comment_id() {
	local text="$1" id="$2" help="$3"

	bprof comment_id start
	if [ "$ROCKCFG_EXPERT" -eq 1 -o "$expert" -eq 0 ]
	then
		echo "$id '$spacer$text'" >> $swpdir/config.dialog.$menu_this

		set_help "$id" "$help"
	fi
	bprof comment_id stop
}

const() {
	bprof const start
	eval "$1=\"\$2\""
	bprof const stop
}

# Usage: set_data NAME DEFAULT
#
set_data() {
	local name="$1" q="'"
	data="$2"
	bprof set_data start

	set_name="ROCKCFGSET_${name#ROCKCFG_}"
	usr_name="ROCKCFGUSR_${name#ROCKCFG_}"
	usr_data="${!usr_name}"

	if [ "${!set_name}" ]; then
		data="${!set_name}"
	fi
	dfl_data="$data"

	if [ "$ROCKCFG_EXPERT" -eq 1 -o "$expert" -eq 0 ]; then
		if [ -n "$usr_data" ]; then
			data="$usr_data"
			obegin="<" oend=">"
		else
			unset $usr_name
		fi
	fi

	eval "$name=\"\$data\""
	item="$name"
	bprof set_data stop
}

choice() {
	bprof choice start
	local obegin="(" oend=")"
	local q="'"
	local name="$1" default="$2"

	set_data "$name" "$default"

	# if data is not in list, leave usr_data unmodified
	# but set the current value to the default
	local fallback_hack=0
	eval $(
		shift 2
		while [ "$#" != 0 ] ; do
			[ "$1" = "$default" ] && exit
			shift 2
		done
		echo "fallback_hack=1"
	)
	if [ "$fallback_hack" = 1 ]; then
		obegin="?"; oend="?"; data="$dfl_data"; eval "$name=\"\$data\""
	fi

	if [ "$ROCKCFG_EXPERT" -eq 1 -o "$expert" -eq 0 ]
	then
		{ echo -en "$item\tchoice_action '$usr_name' '$usr_data'"
		  echo -n " '' 'Reset_this_switch_to_default_value'"
		  shift 2 ; printf " '%s'" "$@" ; echo
		} >> $swpdir/config.data.$menu_this

		xdata="$obegin$data$oend"

		while [ "$1" -a "$1" != "$data" ] ; do shift 2 ; done
		printf "'$item' '$spacer%-${tabspace}s ${2//_/ }'\n" "$xdata" \
			>> $swpdir/config.dialog.$menu_this
	fi

	bprof choice stop
}

choice_action() {
	item="$1" ; default="$2" ; shift 2

	command="./src/rockdialog.bin --title 'Build Config' \
		--backtitle '$configtitle' \
		--radiolist 'Arrow keys navigate the menu.  Press <Enter> to activate menu items.  Highlighted letters are hotkeys.' \
		$(( $lines - 4 )) $(( $columns - 5 )) $(( $lines - 12 ))"
	while [ "$#" -gt 1 ] ; do
		command="$command '$1' '${2//_/ }'"
		if [ "$1" = "$default" ]
		then command="$command ON"
		else command="$command OFF" ; fi
		shift 2
	done
	eval "$command" 2> $swpdir/config.out

	case "$?" in
		0|6)
			eval "$item='`cat $swpdir/config.out`'"
			set_data "${item/ROCKCFGUSR/ROCKCFG}" "$default"
			;;
		1|255) return 0 ;;
		2) echo "No help." ; sleep 1 ;;
		*) echo "unknown returncode: $?" ; exit 1 ;;
	esac
}

text() {
	local name="$1" id="$2" default="$3" help="$4"
	bprof text start
	local q="'" obegin="(" oend=")"

	set_data "$id" "$default"

	if [ "$ROCKCFG_EXPERT" -eq 1 -o "$expert" -eq 0 ]
	then
		echo -e "$id\ttext_action '$name' '$usr_name'" \
			"'${data//$q/$q\\$q$q}'" >> $swpdir/config.data.$menu_this

		xdata="${obegin}$( printf "%-${tabspace}s" \
			"$(echo $data | cut -c1-20)")${oend}"

		printf "'$id' '$spacer%s $name'\n" \
			"${xdata//$q/$q\\$q$q}" >> $swpdir/config.dialog.$menu_this

		set_help "$id" "$help"
	fi
	bprof text stop
}

text_action() {
	local label="$1" usrvar="$2" data="$3"

	./src/rockdialog.bin --title 'Build Config' \
		--backtitle "$configtitle" \
		--inputbox "$label" 9 $(( $columns - 5 )) "$data" 2> $swpdir/config.out
	if [ "$?" -eq 0 -o "$?" -eq 1 ] ; then
		eval "$usrvar=\"\$(cat $swpdir/config.out)\""
		set_data "${usrvar/ROCKCFGUSR/ROCKCFG}" "$data"
	fi
}

bool() {
	local name="$1" id="$2" default="$3" help="$4"
	local x obegin="[" oend="]"

	bprof bool start
	set_data "$id" "$default"

	if [ "$ROCKCFG_EXPERT" -eq 1 -o "$expert" -eq 0 ]
	then
		if [ $data -eq 0 ] ; then
			x="${obegin} ${oend}"
		else	
			x="${obegin}*${oend}"
		fi
		echo -e "$id\tbool_action '$usr_name' '$usr_data' '$default'" \
			>> $swpdir/config.data.$menu_this

		printf "$id '$spacer%-${tabspace}s ${name//_/ }'\n" "$x" \
			>> $swpdir/config.dialog.$menu_this

		set_help "$id" "$help"
	fi
	bprof bool stop
}

bool_action() {
	local usrvar=$1 origval=$3

	case "${!usrvar}" in
		"")	[ "$origval" == "0" ] && eval "$usrvar=1"
			[ "$origval" == "1" ] && eval "$usrvar=0"
			;;
		1)	[ "$origval" == "0" ] && eval "$usrvar=0"
			[ "$origval" == "1" ] && eval "$usrvar="
			;;
		0)	[ "$origval" == "0" ] && eval "$usrvar="
			[ "$origval" == "1" ] && eval "$usrvar=1"
			;;
	esac
	set_data "${usrvar/ROCKCFGUSR/ROCKCFG}" "$3"
}

editfile() {
    local id="$1" file="$2" label="$3"

    bprof editfile start
    if [ "$ROCKCFG_EXPERT" -eq 1 -o $expert -eq 0 ] ; then
	local x="$spacer" q="'"
	comment ",----< $label >----."
	block_begin 0 ; spacer="${spacer%??}| "

	touch "$file"
	line_nr=1
	while read line ; do
		line="${line//$q/$q\\$q$q}"
		printf "$id:${editfilenr} '$spacer%-${tabspace}s %s'\n" \
		    `printf "%03d:" $line_nr` "$line" >> $swpdir/config.dialog.$menu_this

		echo -e "$id:${editfilenr}\teditfile_action $file" \
			"$line_nr '$label'" >> $swpdir/config.data.$menu_this

		editfilenr=$(( $editfilenr + 1 ))
		line_nr=$(( $line_nr + 1 ))
	done < "$file"

	printf "$id:${editfilenr} '$spacer%-${tabspace}s %s'\n" \
	       `printf "%03d:" $line_nr` "<add new rule>" >> $swpdir/config.dialog.$menu_this

	echo -e "$id:${editfilenr}\teditfile_action $file" \
		"$line_nr '$label'" >> $swpdir/config.data.$menu_this

	editfilenr=$(( $editfilenr + 1 ))

	block_end
	comment "\`------${label//?/-}------'\''"
	spacer="$x"
    fi
    bprof editfile stop
}

editfile_action() {
	local filename="$1"

	cp -a "$filename"{,.orig}
	${EDITOR:-vim} "$filename" && rm -f "$filename.orig" \
		|| mv "$filename"{.orig,}
}

startprog() {
	local id="$1" label="$2" prog="$3"

	bprof startprog start
	if [ "$ROCKCFG_EXPERT" -eq 1 -o $expert -eq 0 ]
	then
		printf "$id '$spacer%-${tabspace}s %s'\n" \
		       "-->" "$label" >> $swpdir/config.dialog.$menu_this
		echo -e "$id\t$prog" >> $swpdir/config.data.$menu_this
	fi
	bprof startprog stop
}

block_begin() {
	bprof block_begin start
	[ "$tabspace_list" ] && spacer="$spacer  "
	tabspace_list="$tabspace $tabspace_list"
	tabspace="$(( $tabspace + $1 - 2 ))"
	bprof block_begin stop
}

block_end() {
	bprof block_end start
	spacer="${spacer%??}"
	tabspace="${tabspace_list%% *}"
	tabspace_list="${tabspace_list#* }"
	bprof block_end stop
}

# has to be called at the beginning of each config cycle
config_cycle() {
	expert=0
	menu_counter=0 ; commentnr=0 ; editfilenr=0
	spacer="" ; tabspace="5" ; tabspace_list=""
}

expert_begin() {
	expert=$(( $expert + 1 ))
}

expert_end() {
	expert=$(( $expert - 1 ))
}

menu_begin() {
	local id="$1" name="$2"
	bprof menu_begin start
	menu_counter=$(( $menu_counter + 1 ))

	if [ "$ROCKCFG_EXPERT" -eq 1 -o $expert -eq 0 ]
	then
		printf "$id '$spacer%-${tabspace}s %s'\n" \
			"===>" "$name" >> $swpdir/config.dialog.$menu_this
		echo -e "$id\tmenu_current=$menu_counter" \
			>> $swpdir/config.data.$menu_this

		echo "$id '===> $name'" >> $swpdir/config.dialog.$menu_counter
		echo -e "$id\tmenu_current=$menu_this current=$id" \
			>> $swpdir/config.data.$menu_counter
		echo -e "MENU_BACK\tmenu_current=$menu_this current=$id" \
			>> $swpdir/config.data.$menu_counter
	fi

	menu_stack="$menu_this $menu_stack"
	menu_this=$menu_counter

	block_begin 3
	bprof menu_begin stop
}

menu_end() {
	bprof menu_end start
	block_end
	menu_this="${menu_stack%% *}"
	menu_stack="${menu_stack#* }"
	bprof menu_end stop
}

set_help() {
	local id="$1" help="$2"

	bprof set_help start
 	if [ "$help" != "" ] ; then
		echo -e "$id $help\n\n" >> $swpdir/config.help
 	fi
	bprof set_help stop
}

get_help() {
	local item_name="$1" tmp_text hlp_text default_text

	bprof get_help start

	cat << EOT

This is the ROCK Linux $rockver Configuration Tool.

Config option types:
	[*] [ ]		Unmodified bool value (set and unset)
	<*> < >		User-modified bool value (set and unset)
	(foobar)	Unmodified selection or text field
	<foobar>	User-modified selection or text field

Note that e.g. bool value are in fact tristate options:
user set, user unset and and the unmodified default value

This is because one option might change the default value
of another option. You might need a while to get used to
the concept, but in the end it really makes sense.

-----
EOT

	# Create standard help output ...
	default_text="
There is no help on '$item_name' available.

Please read the build Documentation (Documentation/BUILD)
before building ROCK Linux.

More information can be found on the ROCK Linux Homepage:

	       http://www.rocklinux.org/

Information about the ROCK Linux mailing lists and the mailing
list archive can be found at:

               http://www.rocklinux.org/wiki/Mailing_Lists and
               http://www.rocklinux.net/lurker/splash"
	
	# Ok let us find a help for the current item ...
	hlp_text="$( sed -e "/^$item_name\$/,/^\$/ p ; d" \
		misc/*/{,*/}config*.hlp package/*/*/{sub,}config-*.hlp \
		{scripts,target/*}/config*.hlp 2>/dev/null )"
	
	# Get help strings out of the temporary file.
	tmp_text="$( sed -e "/^[ 	]*$item_name\([ 	]\|\$\)/,/^\$/ p ; d" \
		 $swpdir/config.help 2>/dev/null )"

	# Let us see what we have ...
	if [ "$hlp_text" -a "$tmp_text" ] ; then
		echo "
There are two help text's... one in one of the config.in files and one
in one of the config.hlp files. Please remove one of them to get rid of
this message here.

Here the one out of config.in:

$tmp_text

Here the one out of config.hlp:

$hlp_text"
	elif [ "$hlp_text" ] ; then
		echo "config.hlp: $hlp_text"
	elif [ "$tmp_text" ] ; then
		echo "config.in: $tmp_text"
	else
		echo "$default_text"
	fi
	bprof get_help stop
}
